CODE
; Configura PORT A como saida (TRIS A = 0)
    ORG	    0x00
    BCF	    0x03, 0x06	; STATUS RP1 = 0
    BCF	    0x03, 0x05	; STATUS RP0 = 0
    CLRF    0x05	; LIMPA PORT A
    
    BSF	    0x03, 0x05	; STATUS RP0 = 1 
    MOVLW   0x00	; MOVE 0 PARA W
    MOVWF   0x05	; MOVE W PARA F 0x05
    
; Configura PORT B como entrada (TRIS B = 1)
    BCF	    0x03, 0x05	; STATUS RP0 = 0
    CLRF    0x06	; LIMPA PORT B
    
    BSF	    0x03, 0x05	; STATUS RP0 = 1
    MOVLW   0xFF	; MOVE 255 PARA W
    MOVWF   0x06	; MOVE W PARA F 0x06
    
    BCF	    0x03, 0x05  ; STATUS RP0 = 0
    
; LOOP principal (20MHz ou 20.000.000op/s ou 20.000op/ms)
main_loop:
    MOVLW   0x00	; LIMPA W
    MOVWF   0x21	; RESETA O CONTADOR
    MOVWF   0x24	; RESETA O SEGUNDO CONTADOR
    ADDWF   0x06, 0x00	; MOVE PORTB PARA W
    MOVWF   0x20	; MOVE W PARA 0x20 (SALVA PORTB)  (4OP so far) 
inner_loop: ; Executar 400 vezes antes de ler novamente
    INCF    0x21	; ADICIONA AO CONTADOR
    MOVLW   0x00	; LIMPA W
    ADDWF   0x20, 0x00	; MOVE O VALOR SALVO PARA W
    SWAPF   0x20, 0x01	; GIRA OS NIBBLES DO VALOR SALVO
    ANDLW   0x0F	; DEIXA SÓ OS 4 BITS MENOS SIGNIFICATIVOS
    MOVWF   0x05	; APRESENTA W NA PORTA
    CALL    wait	; ESPERA 5ms
    MOVLW   0xC8	; MOVE 200 PARA W
    SUBWF   0x21, 0x00	; SUBTRAI W DO CONTADOR
    BTFSS   0x03, 0x00	; SE NÃO TEVE CARRY ENTÃO DEVEMOS ZERAR O CONTADOR
    GOTO    inner_loop	; SE TEVE CARRY CONTINUAMOS NO INNER_LOOP
    MOVLW   0x00	; MOVE 0 PARA W
    MOVWF   0x21	; ZERA O CONTADOR
    INCF    0x24	; INCREMENTA O SEGUNDO CONTADOR
    MOVLW   0x02	; MOVE 2 PARA W
    SUBWF   0x24, 0x00	; SUBTRAI W DO SEGUNDO CONTADOR
    BTFSC   0x03, 0x00	; SE NÃO TEVE CARRY DEVEMOS CONTINUAR NO INNER LOOP
    GOTO    inner_loop
    GOTO    main_loop	; SE TEVE CARRY DEVEMOS LER A PORTB DE NOVO
    
wait: ; 7 OP QUANDO EH CHAMADO
    MOVLW   0x00	; LIMPA W
    MOVWF   0x22	; ZERA O CONTADOR
wait_loop1: ; 6 OP
    INCF    0x22	; INCREMENTA O CONTADOR
    MOVLW   0x27	; MOVE 39 PARA W
    SUBWF   0x22, 0x00	; SUBTRAI W DO CONTADOR
    BTFSC   0x03, 0x00	; SE O CONTADOR FOR IGUAL A 39 RETORNE 
    RETURN
    MOVLW   0x00	; LIMPA W
    MOVWF   0x23	; ZERA O SEGUNDO CONTADOR
wait_loop2:
    INCF    0x23	; INCREMENTA O SEGUNDO CONTADOR
    MOVLW   0xFF	; MOVE 255 PARA W
    SUBWF   0x23, 0x00	; SUBTRAI 255 DO SEGUNDO CONTADOR
    BTFSS   0x03, 0x00	; SE NÃO TEVE CARRY VOLTAMOS AO PRIMEIRO LOOP
    GOTO    wait_loop2
    GOTO    wait_loop1
END